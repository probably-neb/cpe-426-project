
# Trojan Description

Our final circuit consisted of an infected AES module as well as a UART module that read the keys and 128b plaintext blocks from the Basys3's micro-usb port, passsed them to the AES module to be encrypted, and returned the ciphertext back on the serial connection. The AES key was also 128b and was assumed to be the first block sent on startup. Additionally a button was wired up to reset the key. After the button was pressed the next block sent over the serial connection would be the new key. The key was stored in the AES module after being set.

The trojan could be triggered by sending a plaintext block with a specific set of bits set to a predefined value 63 times in a row. The value of 63 was chosen as it blended in with the other constant values used throughout the AES module that followed the pattern 2^n - 1. Upon recieving a plaintext block the AES module checked if the 10th, 16th, 92nd, and 107th bits were set to 1,0,1,0 respectively. These values were chosen at random, and were intended to be specific enough that it would be unlikely for the trojan to be triggered during normal use. When a block with the aforementioned bits set correctly was received by the AES module, an internal counter would be incremented. The counter would output a value of 1 if its value equaled 63, 0 otherwise, and would wrap around to 0 after reaching 63. The output of the 9th round of AES encryption was combined with the output of the counter using a logical or, causing the input to the last round to be all 1's when the counter output was 1, and leaving it unchanged otherwise. This encompassed the payload. Because the input to the last round was a known value once the payload had been triggered, the final round key could be derived from the resulting ciphertext. The previous round keys as well as the secret key itself could then be derived from the final round key using the %% KEY REVERSAL ALGORITHM %%.

It is worth noting that the value of the counter was incremented after it's output had been used in the encryption process, i.e. the payload would be delivered in the ciphertext resulting from the encryption of the next block sent after the 63 trigger blocks. The counter would also be reset after the block containing the payload was sent.

# Trojan Applications

While our implementation required the key to be sent over the serial connection, the usefulness of our trojan depends only on the encryption key being stored on the device and used for some extended period of time (i.e. not rotated often), and the attacker having (possibly physical) access to the infected AES module. Therefore it is likely that our trojan would not effective in a consumer chip/cpu containing a hardware based AES accelerator. In this case it is more likely that the keys are managed by an os or user land program and sent to the accelerator for use in encryption and are not stored long term by the AES module. 

In an Iot or embedded device device, however, it is more likely that the encryption keys are hardware (PUF) based, preset by the manufacturer, or rotated on a set schedule. In such cases our trojan becomes a very scary thing to have on your device. With physical access and knowledge of the circuitry of the infected device, an attacker could encrypt the required 64 blocks, save the resulting ciphertext containing the payload for later analysis, and leave. Potentially without leaving any signs the device had been tampered with as the AES module would just resume normal functioning. The attacker would then be able to decrypt all future messages encrypted with the derived key as well as any past messages they had collected either from network traffic or from the device while they had physical access. 

If the AES module is accessible wirelessly it gets worse. This could be the case if the device uses the AES module to decrypt and encrypt wireless messages. If the network protocol used by the device supports an echo,ping, or similar message/protocol, the trojan could be triggered without knowing the encryption key used for communication by finding a collision through messages to the infected device. As only 4 bits need to be set correctly, a collision could be found very easily. Using the birthday paradox it would take an estimated 2^(n/2)=2^(4/2)=4 attempts to find a block that results in a collision. After such a block was found a message containing the block 64 times could be sent in an echo request resulting in the payload being delivered in the 64th block of the response. If no echo protocol is supported, it's plausible that something similar could be added as access to the manufacturing process is a prerequisite for the trojan.

Overall the trojan we implemented requires a significant number of prerequisite conditions to be met in order to be dangerous. Those being broadly; Access to the manufacturing process or manufactured devices in order to insert the malicious AES module. As well as access to the devices later either physically or wirelessly in order to trigger the trojan and collect the payload. This level of access is most likely reserved to state actors, however, if achieved, the result is a very dangerous and very hard to detect trojan.

# Trojan Hunt Results

The team tasked with finding our trojan revealed a secondary trojan that was unintentional in our design. This being that the LEDs on the device revealed a singular byte of the AES key. This was caused by the UART module which would light up the LEDS to indicate that it was reading input successfully. A feature that was added soley for debugging purposes. It could have been useful if we found a way to leak every byte of the key, however, not nearly as dangerous as the actual trojan, which the other team was unable to identify.
